/**
 * Pre-build script: copies only images referenced by published blog posts
 * and _website pages from MyHub/_Organization/_Media/ into public/media/.
 *
 * Safety: only wipes public/media/ if a .generated marker exists (or dir doesn't exist).
 */
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT = path.resolve(__dirname, "..");
const VAULT = path.resolve(process.env.VAULT_PATH || path.join(ROOT, "..", "MyHub"));
const MEDIA_SRC = path.join(VAULT, "_Organization", "_Media");
const MEDIA_DEST = path.join(ROOT, "public", "media");
const MARKER = path.join(MEDIA_DEST, ".generated");

// Image extensions we handle
const IMAGE_EXTS = new Set([".png", ".jpg", ".jpeg", ".gif", ".svg", ".webp"]);

// Regex to extract wiki-image references: ![[filename.ext]] or ![[filename.ext | ...]]
const WIKI_IMAGE_RE = /!\[\[([^\]|]+?)(?:\s*\|[^\]]*?)?\]\]/g;

// ── 1. Find published posts and website pages, extract image references ──

function getPublishedPosts() {
  const posts = [];
  walkDir(VAULT, (filePath) => {
    if (!filePath.endsWith(".md")) return;
    const content = fs.readFileSync(filePath, "utf-8");
    // Quick check for published: true in frontmatter
    const fmMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
    if (!fmMatch) return;
    if (/published:\s*true/i.test(fmMatch[1])) {
      posts.push({ filePath, content });
    }
  });
  return posts;
}

function getWebsitePages() {
  const websiteDir = path.join(VAULT, "_website");
  const pages = [];
  if (!fs.existsSync(websiteDir)) return pages;
  for (const entry of fs.readdirSync(websiteDir, { withFileTypes: true })) {
    if (!entry.isFile() || !entry.name.endsWith(".md")) continue;
    const filePath = path.join(websiteDir, entry.name);
    const content = fs.readFileSync(filePath, "utf-8");
    pages.push({ filePath, content });
  }
  return pages;
}

function walkDir(dir, callback) {
  if (!fs.existsSync(dir)) return;
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      walkDir(full, callback);
    } else {
      callback(full);
    }
  }
}

function extractImageRefs(posts) {
  const refs = new Set();
  for (const { content } of posts) {
    for (const match of content.matchAll(WIKI_IMAGE_RE)) {
      const filename = match[1].trim();
      const ext = path.extname(filename).toLowerCase();
      if (IMAGE_EXTS.has(ext)) {
        refs.add(filename);
      }
    }
  }
  return refs;
}

// ── 2. Build source path map from _Media directory ──

function buildSourceMap() {
  const map = new Map(); // filename → absolute source path
  walkDir(MEDIA_SRC, (filePath) => {
    const ext = path.extname(filePath).toLowerCase();
    if (!IMAGE_EXTS.has(ext)) return;
    const name = path.basename(filePath);
    if (!map.has(name)) {
      map.set(name, filePath);
    }
  });
  return map;
}

// ── 3. Copy referenced images ──

function main() {
  // Safety check: only wipe if .generated marker exists or dir doesn't exist
  if (fs.existsSync(MEDIA_DEST)) {
    if (!fs.existsSync(MARKER)) {
      console.error(
        "ERROR: public/media/ exists but has no .generated marker. " +
          "Refusing to wipe — it may contain manually placed files."
      );
      process.exit(1);
    }
    fs.rmSync(MEDIA_DEST, { recursive: true });
  }

  const posts = getPublishedPosts();
  console.log(`Found ${posts.length} published posts`);

  const websitePages = getWebsitePages();
  console.log(`Found ${websitePages.length} website pages`);

  const imageRefs = extractImageRefs([...posts, ...websitePages]);
  console.log(`Found ${imageRefs.size} unique image references`);

  const sourceMap = buildSourceMap();

  // Create destination directories
  fs.mkdirSync(path.join(MEDIA_DEST, "_excalidraw"), { recursive: true });

  let copied = 0;
  let missing = 0;

  for (const ref of imageRefs) {
    // Try bare filename lookup first, then basename (for path-prefixed refs),
    // then as a vault-relative path
    const srcPath =
      sourceMap.get(ref) ||
      sourceMap.get(path.basename(ref)) ||
      (fs.existsSync(path.join(VAULT, ref)) ? path.join(VAULT, ref) : null);
    if (!srcPath) {
      console.warn(`  WARN: no source found for "${filename}"`);
      missing++;
      continue;
    }

    // Preserve _excalidraw subdirectory structure
    const relFromMedia = path.relative(MEDIA_SRC, srcPath);
    const destPath = path.join(MEDIA_DEST, relFromMedia);

    fs.mkdirSync(path.dirname(destPath), { recursive: true });
    fs.copyFileSync(srcPath, destPath);
    copied++;
  }

  // Write .generated marker
  fs.writeFileSync(MARKER, "This directory is auto-generated by scripts/copy-media.mjs\n");

  console.log(`Copied ${copied} images, ${missing} missing`);
}

main();
